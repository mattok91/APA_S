FUNCTION_BLOCK "LAxisCtrl_SpeedAxis"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'tech.team.motioncontrol@siemens.com'
FAMILY : AxisCtrl
VERSION : 1.1
   VAR_INPUT 
      enable : Bool := FALSE;
      enableAxis : Bool := FALSE;
      resetAxis : Bool := FALSE;
      openBrake : Bool := FALSE;
      jogForward : Bool := FALSE;
      jogBackward : Bool := FALSE;
      moveVelocity : Bool := FALSE;
      stop : Bool := FALSE;
      fastStop : Bool := FALSE;
      torqueLimiting : Bool := FALSE;
      axis {InstructionName := 'TO_SpeedAxis'; LibVersion := '5.0'} : TO_SpeedAxis;
      configuration : "LAxisCtrl_typeAxisConfig";
   END_VAR

   VAR_OUTPUT 
      valid { ExternalWritable := 'False'} : Bool := FALSE;
      busy { ExternalWritable := 'False'} : Bool := FALSE;
      error { ExternalWritable := 'False'} : Bool := FALSE;
      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;
      subfunctionStatus { ExternalWritable := 'False'} : Word;
      axisEnabled { ExternalWritable := 'False'} : Bool := FALSE;
      resetActive { ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool := FALSE;
      commandBusy { ExternalWritable := 'False'} : Bool := FALSE;
      commandDone { ExternalWritable := 'False'} : Bool := FALSE;
      commandAborted { ExternalWritable := 'False'} : Bool := FALSE;
      inVelocity { ExternalWritable := 'False'} : Bool := FALSE;
      inLimitation { ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool := FALSE;
      jogSelected { ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool := FALSE;
      moveVelocitySelected { ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool := FALSE;
      stopSelected { ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool := FALSE;
      fastStopSelected { ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool := FALSE;
      torqueLimitingSelected { ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : Bool := FALSE;
      diagnostics { ExternalWritable := 'False'; S7_HiddenAssignment := 'HideIfNoParamAssigned'} : "LAxisCtrl_typeDiagnostics";
   END_VAR

   VAR 
      statErrorUserCleared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;
      statErrorAutoCleared { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;
      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;
      statSubfunctionStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      statDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "LAxisCtrl_typeDiagnostics";
      statEnableOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;
      statFBState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : SInt := #AXIS_MOTION;
      statFirstCycleReset { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;
      statPowerErrorOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;
      statResetState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := #CMD_IDLE;
      statFirstCycleResetError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;
      statExtendedCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord := #CMD_NO_SELECTION;
      statExtendedCommandOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord := #CMD_NO_SELECTION;
      statEnableAxisOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;
      statEmptyDiagnostics { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "LAxisCtrl_typeDiagnostics";
      statBasicCommand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord := #CMD_NO_SELECTION;
      statBasicCommandOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord := #CMD_NO_SELECTION;
      statBasicMotionState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #NO_SELECTION;
      statExeOfBasicMotion { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := #CMD_BUSY;
      statFirstCycleBasicMotion { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;
      statApplicativeBasicMotionError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;
      statVelocityChangeOnTheFly { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;
      statVelocity { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := 0.0;
      statAcceleration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := 0.0;
      statAbortAcceleration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;
      statDeceleration { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := 0.0;
      statJerk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := 0.0;
      statPositionControlled { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;
      statFirstCycleDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;
      statTorqueLimitingState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : SInt := #NO_TORQUE_LIMITING_ACTIVE;
      statTorqueLimitingErrorOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := FALSE;
      statTorqueLimit { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : LReal := -1.0;
      statJogMode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #JOG_MODE_CONTINUOUS;
      statDirection { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int := #SPECIFIED_DIR;
      statStopWithoutSignalization { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statBrakeOpened { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statBrakeChangeActive { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statOpenBrakeOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      instPower {InstructionName := 'MC_POWER'; LibVersion := '5.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : MC_POWER;
      instReset {InstructionName := 'MC_RESET'; LibVersion := '5.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : MC_RESET;
      instHalt {InstructionName := 'MC_HALT'; LibVersion := '5.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : MC_HALT;
      instMoveJog {InstructionName := 'MC_MOVEJOG'; LibVersion := '5.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : MC_MOVEJOG;
      instTorqueLimiting {InstructionName := 'MC_TORQUELIMITING'; LibVersion := '5.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : MC_TORQUELIMITING;
      instMoveVelocity {InstructionName := 'MC_MOVEVELOCITY'; LibVersion := '5.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : MC_MOVEVELOCITY;
      instSetAxisSTW {InstructionName := 'MC_SETAXISSTW'; LibVersion := '5.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : MC_SETAXISSTW;
   END_VAR

   VAR_TEMP 
      tempEnable : Bool;
      tempNewExtendedCmd : DInt;
      tempEnableAxis : Bool;
      tempErrorInCmd : Bool;
      tempRisingCmd : DWord;
      tempStopCmdSelected : Bool;
      tempOpenBrake : Bool;
      tempDword : DWord;
      tempIndex : Int;
      tempCountRisEdges : USInt;
      tempNewBasicMotionCmd : DInt;
      tempStateChangeActive : Bool;
      tempStatusWord : DWord;
   END_VAR

   VAR CONSTANT 
      AXIS_MOTION : SInt := 1;
      FB_ERROR : SInt := 5;
      CMD_NO_SELECTION : DWord := 16#0000_0000;
      NO_SELECTION : Int := 0;
      AXIS_FAST_STOPPING : SInt := 2;
      AXIS_STOP_ON_ERROR_SELECTION : SInt := 3;
      AXIS_STOP_ON_ERROR_EXECUTION : SInt := 4;
      FAST_STOP_SELECTED : Int := 1;
      STOP_SELECTED : Int := 2;
      JOG_FORWARD_SELECTED : Int := 4;
      JOG_BACKWARD_SELECTED : Int := 8;
      JOG_FW_AND_BW_SELECTED : Int := 12;
      MOVE_VELOCITY_SELECTED : Int := 16;
      ACTIVE_HOMING_SELECTED : Int := 1024;
      CMD_IDLE : Int := 0;
      CMD_BUSY : Int := 1;
      JOG_MODE_CONTINUOUS : Int := 0;
      NO_TORQUE_LIMITING_ACTIVE : SInt := 0;
      TORQUE_LIMTING_SELECTED : SInt := 1;
      TORQUE_LIMITING_DISABLE : SInt := 10;
      BITPOSITION_BASIC_MOTION_CMD : SInt := 4;
      BIT_POS_LAST : SInt := 15;
      SPECIFIED_DIR : Int := 0;
      MASK_STW_BIT12 : Word := 16#1000;
      STATUS_NO_CALL : Word := 16#7000;
      STATUS_FB_FIRST_CALL : Word := 16#7001;
      STATUS_SUBSEQUENT_CALL : Word := 16#7002;
      ERR_INVALID_BASIC_MOTION_CMD : Word := 16#8001;
      ERR_INVALID_JOG_MODE : Word := 16#8201;
      ERR_MC_POWER : Word := 16#8600;
      ERR_MC_RESET : Word := 16#8601;
      ERR_MC_TORQUELIMITING : Word := 16#8603;
      ERR_MC_HALT : Word := 16#8604;
      ERR_MC_MOVEJOG : Word := 16#8605;
      ERR_MC_MOVEVELOCITY : Word := 16#8606;
      ERR_UNDEFINED_FB_STATE : Word := 16#8700;
      ERR_UNDEFINED_RESET_STATE : Word := 16#8701;
      ERR_UNDEFINED_BASIC_MOTION_STATE : Word := 16#8702;
      ERR_UNDEFINED_TORQUE_LIMITING_STATE : Word := 16#8703;
   END_VAR


BEGIN
	//================================================================================
	// SIEMENS AG
	// (c)Copyright 2020 All Rights Reserved
	//--------------------------------------------------------------------------------
	// Library: LAxisCtrl 
	// Tested with: S7-1515T-2 PN
	// Engineering: TIA Portal V16
	// Restrictions: -
	// Requirements: S7-1500/S7-1500T FW 2.8.1
	// Functionality: This function block offers basic functionalities for axis control
	// Support: tech.team.motioncontrol@siemens.com
	// Note: Parameter comments are only available in language 'English (United States)'
	//--------------------------------------------------------------------------------
	// Change log table:
	// Version  Date        Expert in charge  Changes applied
	// 01.00.01 12.10.2016  RS                First released version
	// 01.00.02 29.03.2017  RS                Added support information
	//                                        TorqueLimiting at FB Enable                                                   
	//                                        Block is compilable with V14 SP1
	//                                        fastStop: Use TO emergency stop deceleration in case of configured value <= 0 
	//                                        fastStop: Configured jerk value is always used                                
	// 01.00.03 14.06.2017  RS                Reset MC_TORQUELIMITING instance with disable of FB                           
	//                                        Bugfix of error handling for MC_TORQUELIMITING                                
	// 01.00.04 14.12.2017  RS                Initialize diagnostics at rising edge of torquelimiting command               
	// 01.00.05 30.09.2019  RS                Bugfixes
	//                                        Ratio on the fly: use also new dynamics if "on the fly value" changed         
	//                                        Stop on Error function: No error display if error at MC_Halt                  
	// 01.01.00 31.03.2020  RS                New output "subfunctionStatus"
	//                                        Change of parameter configuration: INOUT --> IN
	//                                        New input: "open brake"                                                       
	//                                        Stop on Error function: Error and status outputs remain also if internally        
	//                                        called MC_Halt instruction is executed                                        
	//                                        Output "diagnostics" is only written at end of block             
	//================================================================================
	
	//----------------------------------------------------------------------------------------------
	// Enable / disable FB
	//----------------------------------------------------------------------------------------------
	
	#tempEnable := #enable; // Create temporary process image
	
	REGION ENABLE_FB
	  IF NOT #tempEnable AND #statEnableOld THEN
	    REGION FALLING_EDGE_AT_ENABLE_FB
	      
	      // Reset outputs 
	      // ==========================================================
	      // Error and valid outputs are reset with falling edge of enable input
	      #error := FALSE;
	      #valid := FALSE;
	      #status := #STATUS_NO_CALL;
	      #subfunctionStatus := #statSubfunctionStatus := 16#0; // V1.1.0
	      
	      // Reset status outputs
	      #axisEnabled := FALSE;
	      #resetActive := FALSE;
	      
	      // Reset outputs for torquelimiting command
	      #torqueLimitingSelected := FALSE;
	      #inLimitation := FALSE;
	      
	      // Reset outputs for basic motion commands
	      #commandDone := FALSE;
	      #commandBusy := FALSE;
	      #commandAborted := FALSE;
	      #inVelocity := FALSE;
	      #fastStopSelected := FALSE;
	      #stopSelected := FALSE;
	      #jogSelected := FALSE;
	      #moveVelocitySelected := FALSE;
	      
	      // Reset internal variables
	      // ==========================================================
	      #statErrorUserCleared := FALSE;
	      #statErrorAutoCleared := FALSE;
	      #statStatus := #STATUS_NO_CALL;
	      #statDiagnostics := #statEmptyDiagnostics;
	      
	      #statFBState := #AXIS_MOTION;
	      #statFirstCycleReset := FALSE;
	      #statPowerErrorOld := FALSE;
	      #statResetState := #CMD_IDLE;
	      #statFirstCycleResetError := FALSE;
	      
	      #statExtendedCommand := #CMD_NO_SELECTION;
	      #statExtendedCommandOld := #CMD_NO_SELECTION;
	      #statEnableAxisOld := FALSE;
	      #statBasicCommand := #CMD_NO_SELECTION;
	      #statBasicCommandOld := #CMD_NO_SELECTION;
	      #statBasicMotionState := #NO_SELECTION;
	      #statExeOfBasicMotion := #CMD_BUSY;
	      #statFirstCycleBasicMotion := FALSE;
	      #statApplicativeBasicMotionError := FALSE;
	      #statVelocityChangeOnTheFly := FALSE;
	      #statVelocity := 0.0;
	      #statAcceleration := 0.0;
	      #statAbortAcceleration := FALSE;
	      #statDeceleration := 0.0;
	      #statJerk := 0.0;
	      
	      #statPositionControlled := TRUE;
	      #statFirstCycleDone := FALSE;
	      
	      #statTorqueLimitingState := #NO_TORQUE_LIMITING_ACTIVE;
	      #statTorqueLimitingErrorOld := FALSE;
	      #statTorqueLimit := -1.0;
	      #statJogMode := #JOG_MODE_CONTINUOUS;
	      #statDirection := #SPECIFIED_DIR;
	      // ===========================================================
	      
	      // Disable Axis
	      IF (#instPower.Busy = TRUE) THEN
	        #instPower(Axis := #axis,
	                   Enable := FALSE,
	                   StartMode := #configuration.power.startMode,
	                   StopMode := #configuration.power.stopMode);
	        // Check if error occurred
	        IF (#instPower.Error = TRUE) THEN
	          // Write only diagnostics if error occurred at falling edge of MC_POWER
	          #diagnostics.status := #ERR_MC_POWER;
	          #diagnostics.subfunctionStatus := #instPower.ErrorId;
	          #diagnostics.basicMotionState := #statBasicMotionState;
	        END_IF;
	      END_IF;
	      
	      // Set old value of enable for edge detection and end execution
	      #statEnableOld := #tempEnable;
	      RETURN;
	    END_REGION
	    
	    // Check if FB is enabled - first cycle
	  ELSIF #tempEnable AND NOT #statEnableOld THEN
	    REGION FB_RISING_EDGE_AT_ENABLE_FB
	      // Busy is set at rising edge of enable input
	      #busy := TRUE;
	      #status := #STATUS_FB_FIRST_CALL;
	      // StatStatus will be written in next cycle
	      #statStatus := #STATUS_SUBSEQUENT_CALL;
	      
	      // Reset error and diagnostics outputs
	      #statErrorUserCleared := FALSE;
	      #statErrorAutoCleared := FALSE;
	      #diagnostics := #statEmptyDiagnostics;
	      #statDiagnostics := #statEmptyDiagnostics;
	      
	      // Copy inputs
	      #statExtendedCommand.%X0 := #resetAxis;
	      // #statExtendedCommand.%X1 := #torqueLimiting;  // V1.0.2 Removed for activation at FB Enable 
	      
	      #statBasicCommand.%X0 := #fastStop;
	      #statBasicCommand.%X1 := #stop;
	      #statBasicCommand.%X2 := #jogForward;
	      #statBasicCommand.%X3 := #jogBackward;
	      #statBasicCommand.%X4 := #moveVelocity;
	      #statBasicCommandOld := #statBasicCommand;
	      
	      #statExtendedCommandOld := #statExtendedCommand;
	      // Set old value of enable for edge detection and end execution
	      #statEnableOld := #tempEnable;
	      RETURN;
	    END_REGION
	    
	    // Check if function block is disabled or UserClearedError is present
	  ELSIF NOT #tempEnable OR #statErrorUserCleared THEN
	    REGION FB_DISABLED
	      IF (#tempEnable = FALSE) THEN
	        #status := #STATUS_NO_CALL;
	      END_IF;
	      
	      // Disable Axis
	      IF (#instPower.Busy = TRUE) THEN
	        #instPower(Axis := #axis,
	                   Enable := FALSE,
	                   StartMode := #configuration.power.startMode,
	                   StopMode := #configuration.power.stopMode);
	        // Check if error occurred
	        IF (#instPower.Error = TRUE) THEN
	          #diagnostics.status := #ERR_MC_POWER;
	          #diagnostics.subfunctionStatus := #instPower.ErrorId;
	          #diagnostics.basicMotionState := #statBasicMotionState;
	        END_IF;
	      ELSE
	        // V1.00.03 Reset if torque limiting is busy and axis is disabled 
	        IF (#instTorqueLimiting.Busy = TRUE) THEN
	          #instTorqueLimiting(Axis := #axis,
	                              Enable := FALSE);
	        ELSE
	          #busy := FALSE;
	        END_IF;
	      END_IF;
	      
	      #statEnableOld := #tempEnable;
	      RETURN;
	    END_REGION
	    
	  ELSE
	    REGION FB_ENABLED
	      // Copy extended inputs
	      #statExtendedCommand.%X0 := #resetAxis;
	      #tempEnableAxis := #enableAxis;
	      #statExtendedCommand.%X1 := #torqueLimiting;
	      #statBasicCommand.%X0 := #fastStop;
	      #statBasicCommand.%X1 := #stop;
	      #statBasicCommand.%X2 := #jogForward;
	      #statBasicCommand.%X3 := #jogBackward;
	      #statBasicCommand.%X4 := #moveVelocity;
	      #tempOpenBrake := #openBrake;
	      
	      // Enable and disable axis
	      REGION POWER
	        // Call MC_POWER
	        #instPower(Axis := #axis,
	                   Enable := #tempEnableAxis,
	                   StartMode := #configuration.power.startMode,
	                   StopMode := #configuration.power.stopMode);
	        
	        // Set and Reset of Error
	        IF (#instPower.Error = TRUE) AND
	          ((#statStatus = #STATUS_SUBSEQUENT_CALL) OR (#statPowerErrorOld = FALSE))
	        THEN
	          // Error is set at rising edge of MC_POWER.Error 
	          // Errorhandling
	          #statStatus := #ERR_MC_POWER;
	          #statErrorAutoCleared := TRUE;
	          #statDiagnostics.basicMotionState := #statBasicMotionState;
	          #statDiagnostics.subfunctionStatus := #statSubfunctionStatus := #instPower.ErrorId;
	          
	        ELSIF (#statStatus = #ERR_MC_POWER) AND (#instPower.Error = FALSE)
	        THEN
	          // Reset Error
	          #statStatus := #STATUS_SUBSEQUENT_CALL;
	          #statErrorAutoCleared := FALSE;
	          
	        ELSIF (#tempEnableAxis = TRUE) AND (#statEnableAxisOld = FALSE) THEN
	          // Reset Error
	          #statStatus := #STATUS_SUBSEQUENT_CALL;
	          #statErrorAutoCleared := FALSE;
	          #statDiagnostics := #statEmptyDiagnostics;
	        ELSE
	          ; // Do nothing
	        END_IF;
	      END_REGION
	      REGION BRAKE_CONTROL
	        IF #tempOpenBrake AND NOT #statOpenBrakeOld THEN
	          // Open
	          #instSetAxisSTW(Axis := #axis,
	                          Execute := FALSE,
	                          STW1 := #MASK_STW_BIT12,
	                          STW1BitMask := #MASK_STW_BIT12);
	          #statBrakeChangeActive := TRUE;
	          #statBrakeOpened := TRUE;
	          
	        ELSIF NOT #tempOpenBrake AND #statOpenBrakeOld THEN
	          // Close
	          #instSetAxisSTW(Axis := #axis,
	                          Execute := FALSE,
	                          STW1 := 16#0,
	                          STW1BitMask := #MASK_STW_BIT12);
	          #statBrakeChangeActive := TRUE;
	          #statBrakeOpened := FALSE;
	        END_IF;
	        
	        IF #statBrakeChangeActive THEN
	          // Call of MC command
	          #instSetAxisSTW(Axis := #axis,
	                          Execute := TRUE);
	          
	          IF NOT #instSetAxisSTW.Busy THEN
	            #statBrakeChangeActive := FALSE;
	          END_IF;
	        END_IF;
	        // Edge detection
	        #statOpenBrakeOld := #tempOpenBrake;
	      END_REGION
	    END_REGION
	  END_IF;
	END_REGION
	
	//----------------------------------------------------------------------------------------------
	// FB Statemachine 
	//----------------------------------------------------------------------------------------------
	REGION FB_STATEMACHINE
	  CASE #statFBState OF
	    #AXIS_MOTION:
	      // Check command inputs
	      IF (#statExtendedCommand = #CMD_NO_SELECTION)
	        AND (#statBasicCommand = #CMD_NO_SELECTION)
	      THEN
	        // Command is reset
	        IF (#instPower.Error = TRUE) THEN
	          // Errorhandling
	          #statStatus := #ERR_MC_POWER;
	          #statErrorAutoCleared := TRUE;
	          //#diagnostics := #statDiagnostics;
	          
	        ELSIF (#instTorqueLimiting.Error = TRUE) THEN
	          ; // Do nothing. V1.00.03 dont reset IF torque limiting #error is pending 
	          
	        ELSE
	          // Reset Error only if no Error at MC_POWER is present
	          #statStatus := #STATUS_SUBSEQUENT_CALL;
	          #statErrorAutoCleared := FALSE;
	        END_IF;
	        
	      ELSIF (#statExtendedCommand = #statExtendedCommandOld)
	        AND (#statBasicCommand = #statBasicCommandOld)
	      THEN
	        ; // No change at command - do nothing
	        
	      ELSE
	        // Command changed
	        #tempNewExtendedCmd := #NO_SELECTION;
	        #tempNewBasicMotionCmd := #NO_SELECTION;
	        #tempErrorInCmd := FALSE;
	        
	        REGION CHECK BASIC_MOTION_CMD
	          // Check basic motion command
	          IF (#statBasicCommand = #statBasicCommandOld) THEN
	            ; // Do nothing
	          ELSE
	            // Evaluate rising edges for basic motion command word - all rising edges of basic command word saved in tempRisingBasicCmd
	            #tempRisingCmd := ((#statBasicCommand XOR #statBasicCommandOld) AND #statBasicCommand);
	            #tempCountRisEdges := 0; // Initialize counter for rising edges
	            // Count rising edges in tempRisingBasicCmd
	            FOR #tempIndex := #BITPOSITION_BASIC_MOTION_CMD TO #BIT_POS_LAST DO
	              #tempDword := SHR(IN := #tempRisingCmd, N := INT_TO_USINT(#tempIndex));
	              // Check for rising edge
	              IF (#tempDword.%X0 = TRUE) THEN
	                #tempCountRisEdges := #tempCountRisEdges + 1; // Increment at rising edge
	              END_IF;
	            END_FOR;
	            IF (#tempRisingCmd.%X2 = TRUE) OR (#tempRisingCmd.%X3 = TRUE) THEN
	              #tempCountRisEdges := #tempCountRisEdges + 1; // jogForward AND/OR jogBackward is standing for 1 Command/rising edge
	            END_IF;
	            
	            // Check Basic motion command
	            IF (#tempCountRisEdges = 1)
	              OR (#tempRisingCmd.%X0 = TRUE) // fastStop selected
	              OR (#tempRisingCmd.%X1 = TRUE) // Stop selected
	            THEN
	              // Valid basic motion command selected
	              IF (#tempRisingCmd.%X0 = TRUE)
	              THEN
	                // FastStop selected
	                #statFBState := #AXIS_FAST_STOPPING;
	                #tempNewBasicMotionCmd := #FAST_STOP_SELECTED;
	                #tempStopCmdSelected := TRUE;
	              ELSIF (#tempRisingCmd.%X1 = TRUE)
	              THEN
	                // Stop selected
	                #tempNewBasicMotionCmd := #STOP_SELECTED;
	                #tempStopCmdSelected := TRUE;
	              ELSE
	                // Valid basic command priority 3 selected
	                // Set basic motion state
	                #tempNewBasicMotionCmd := DWORD_TO_DINT(#tempRisingCmd);
	              END_IF;
	              
	            ELSIF (#tempCountRisEdges > 1) THEN
	              // Errorhandling - Invalid command 
	              #statStatus := #ERR_INVALID_BASIC_MOTION_CMD;
	              #tempErrorInCmd := TRUE;
	            ELSE
	              ; // Falling edge detection
	            END_IF;
	          END_IF;
	        END_REGION
	        REGION CHECK_EXT_CMD
	          // Check extended command (reset, homing, torquelimiting)
	          IF (#statExtendedCommand = #statExtendedCommandOld) THEN
	            ; // Do nothing
	          ELSE
	            // Extended command selected
	            IF (#tempErrorInCmd = FALSE)
	            THEN
	              #tempRisingCmd := ((#statExtendedCommand XOR #statExtendedCommandOld) AND #statExtendedCommand);
	              // Rising edge on torquelimiting command
	              IF (#tempRisingCmd.%X1 = TRUE)
	              THEN
	                #tempNewExtendedCmd.%X1 := TRUE;
	              END_IF;
	            ELSE
	              ; // Error in basic motion command or superimposed motion command 
	            END_IF;
	          END_IF;
	        END_REGION
	        // Enable commands
	        IF (#tempErrorInCmd = TRUE) AND (#tempStopCmdSelected = FALSE)
	        THEN
	          // Error in current command - No Execution
	          #statErrorAutoCleared := TRUE;
	          #statDiagnostics.subfunctionStatus := #statSubfunctionStatus := 0;
	          // Write diagnostics
	          #statDiagnostics.basicMotionState := #statBasicMotionState;
	          // Set next state
	          #statFBState := #AXIS_STOP_ON_ERROR_SELECTION;
	        ELSE
	          // No Error in command occurred
	          IF (
	            (#tempNewExtendedCmd <> #NO_SELECTION)
	            OR (#tempNewBasicMotionCmd <> #NO_SELECTION)
	            )
	            OR (#tempStopCmdSelected = TRUE)
	          THEN
	            REGION ENABLE_BASIC_MOTION_CMD
	              // New valid command selected
	              // Basic motion commands
	              IF (#tempNewBasicMotionCmd <> #NO_SELECTION) THEN
	                #statFirstCycleBasicMotion := TRUE;
	                // Evaluate if Jog command is set
	                IF (#tempNewBasicMotionCmd.%X2 = TRUE) OR (#tempNewBasicMotionCmd.%X3 = TRUE)
	                THEN
	                  #statExeOfBasicMotion := #CMD_BUSY;
	                  // Select Jogmode
	                  IF ((#statBasicCommand.%X2 = FALSE) AND (#tempNewBasicMotionCmd.%X3 = TRUE)) OR // Rising edge at JogBackward and JogForward = FALSE
	                    ((#statBasicCommand.%X3 = FALSE) AND (#tempNewBasicMotionCmd.%X2 = TRUE)) OR // Only rising edge at JogForward and Jogbackward = FALSE
	                    ((#tempNewBasicMotionCmd.%X2 = TRUE) AND (#tempNewBasicMotionCmd.%X3 = TRUE)) // Rising edge at FW and BW
	                  THEN
	                    // One Input direction = False, other is rising edge, or both rising edge --> Start jog
	                    #statJogMode := #configuration.jog.mode;
	                  ELSE
	                    // Rising edge at one input, the other is already TRUE - Dont Change Jogmode
	                    IF ((#statBasicMotionState = #JOG_BACKWARD_SELECTED) OR (#statBasicMotionState = #JOG_FORWARD_SELECTED)) AND (#statJogMode <> #JOG_MODE_CONTINUOUS)
	                    THEN
	                      #statFirstCycleBasicMotion := FALSE;
	                    END_IF;
	                  END_IF;
	                ELSE
	                  ; // Reset jog increment if other command than jog selected
	                END_IF;
	                // Set new basic motion state
	                #statBasicMotionState := #tempNewBasicMotionCmd;
	              END_IF;
	            END_REGION
	            // Extended commands
	            REGION ENABLE_EXT_CMD
	              IF (#tempNewExtendedCmd <> #NO_SELECTION) THEN
	                IF (#tempNewExtendedCmd.%X1 = TRUE) THEN
	                  // Rising edge on torquelimiting command
	                  IF (#statTorqueLimitingState = #NO_TORQUE_LIMITING_ACTIVE)
	                  THEN
	                    // No torquelimiting active --> Enable torquelimiting
	                    #statTorqueLimitingState := #TORQUE_LIMTING_SELECTED;
	                  ELSE
	                    ; // Torquelimiting already active
	                  END_IF;
	                END_IF;
	              END_IF;
	            END_REGION
	            // Reset error
	            #statStatus := #STATUS_SUBSEQUENT_CALL;
	            #statErrorAutoCleared := FALSE;
	            #statDiagnostics := #statEmptyDiagnostics;
	          ELSE
	            ; // No rising edge at commands
	          END_IF;
	        END_IF;
	      END_IF;
	      
	    #AXIS_FAST_STOPPING:
	      IF (#configuration.fastStop.replaceStopPossible = FALSE) THEN
	        ; // Fast stop command can not be interrupted by another command
	        // State change is executed in FastStop implementation if command finished 
	      ELSE
	        #statFBState := #AXIS_MOTION;
	      END_IF;
	      
	    #AXIS_STOP_ON_ERROR_SELECTION,
	    #AXIS_STOP_ON_ERROR_EXECUTION:
	      ; // Wait for stopping axis if StopOnError is configured
	    #FB_ERROR: // Error state
	      ; // Do nothing, status already set
	      
	    ELSE
	      // Errorhandling
	      #statStatus := #ERR_UNDEFINED_FB_STATE;
	      #statErrorUserCleared := TRUE;
	      #statDiagnostics.subfunctionStatus := #statSubfunctionStatus := 0;
	      #statDiagnostics.basicMotionState := #statBasicMotionState;
	      // Set error state
	      #statFBState := #FB_ERROR;
	  END_CASE;
	END_REGION
	
	//----------------------------------------------------------------------------------------------
	// Execution of reset functionality
	//----------------------------------------------------------------------------------------------
	REGION EXECUTION_OF_RESET_COMMAND
	  // Firstcycle of command
	  IF (#statExtendedCommand.%X0 = TRUE) AND (#statExtendedCommandOld.%X0 = FALSE) THEN
	    #statFirstCycleReset := TRUE;
	    // Reset MC_RESET command
	    #instReset(Axis := #axis,
	               Execute := FALSE);
	    #statFirstCycleResetError := FALSE;
	    #statResetState := #CMD_BUSY;
	  END_IF;
	  
	  CASE #statResetState OF
	    #CMD_IDLE:
	      ; // Do nothing
	      
	    #CMD_BUSY:
	      // Call MC_Command
	      #instReset(Axis := #axis,
	                 Execute := #statExtendedCommand.%X0,
	                 Restart := #configuration.generalSettings.resetWithRestart);
	      
	      // Evaluate MC_Command
	      IF (#instReset.Error = TRUE) THEN
	        // Errorhandling
	        IF (#statFirstCycleResetError = FALSE) THEN
	          #statErrorAutoCleared := TRUE;
	          #statStatus := #ERR_MC_RESET;
	          #statDiagnostics.status := #ERR_MC_RESET;
	          #statDiagnostics.basicMotionState := #statBasicMotionState;
	          #statDiagnostics.subfunctionStatus := #statSubfunctionStatus := #instReset.ErrorId;
	          #statFirstCycleResetError := TRUE;
	          // Set next state
	          #statResetState := #CMD_IDLE;
	          IF (#statFBState = #AXIS_MOTION) THEN
	            // Set TO_STOP_ON_ERROR State only if the current state is TO_MOTION
	            #statFBState := #AXIS_STOP_ON_ERROR_SELECTION;
	          END_IF;
	        END_IF;
	        
	      ELSIF (#instReset.Busy = FALSE) THEN
	        // Set next state
	        #statResetState := #CMD_IDLE;
	      ELSE
	        ; // Command selected
	      END_IF;
	    ELSE
	      // Errorhandling    
	      #statStatus := #ERR_UNDEFINED_RESET_STATE;
	      #statErrorUserCleared := TRUE;
	      #statDiagnostics.subfunctionStatus := #statSubfunctionStatus := 0;
	      #statDiagnostics.basicMotionState := #statBasicMotionState;
	  END_CASE;
	END_REGION
	
	//----------------------------------------------------------------------------------------------
	// Execution of functionalities of basic coordinate system
	//----------------------------------------------------------------------------------------------
	REGION EXECUTION_OF_BASIC_MOTION_COMMANDS
	  // Statemachine for basic motion commands
	  
	  // Write diagnostics
	  #statDiagnostics.basicMotionState := #statBasicMotionState;
	  CASE #statBasicMotionState OF
	    #NO_SELECTION:
	      ; // No execution
	      
	    #FAST_STOP_SELECTED:
	      ; // Implementation at end of code
	      
	    #STOP_SELECTED:
	      // No additional features
	      REGION STOP_SELECTED
	        // Firstcycle of command
	        IF (#statFirstCycleBasicMotion = TRUE) THEN
	          // Reset HALT command
	          #instHalt(Axis := #axis,
	                    Execute := FALSE);
	        END_IF;
	        
	        // Call MC_Command
	        #instHalt(Axis := #axis,
	                  Execute := #statBasicCommand.%X1 OR #statFirstCycleBasicMotion,
	                  Deceleration := #configuration.stop.deceleration,
	                  AbortAcceleration := #configuration.stop.abortAcceleration,
	                  Jerk := #configuration.stop.jerk);
	        
	        // Evaluate MC_Command
	        IF (#instHalt.Busy = FALSE) AND
	          (#instHalt.Error = FALSE) AND
	          (#instHalt.Done = FALSE) AND
	          (#instHalt.CommandAborted = FALSE)
	        THEN
	          // Return to NO_SELECTION if command finished
	          #statBasicMotionState := #NO_SELECTION;
	          
	        ELSIF (#instHalt.Error = TRUE)
	        THEN
	          // Errorhandling
	          #statStatus := #ERR_MC_HALT;
	          #statErrorAutoCleared := TRUE;
	          #statDiagnostics.subfunctionStatus := #statSubfunctionStatus := #instHalt.ErrorId;
	          // Set next state
	          #statFBState := #AXIS_STOP_ON_ERROR_SELECTION;
	          #statBasicMotionState := #NO_SELECTION;
	        ELSE
	          ; // Command selected
	        END_IF;
	        
	        // Write MC_Command outputs to internal variable
	        #statExeOfBasicMotion := 16#0;
	        #statExeOfBasicMotion.%X0 := #instHalt.Busy;
	        #statExeOfBasicMotion.%X1 := #instHalt.Done;
	        #statExeOfBasicMotion.%X2 := #instHalt.CommandAborted;
	        #statExeOfBasicMotion.%X3 := #instHalt.Error;
	      END_REGION
	      
	    #JOG_FORWARD_SELECTED, #JOG_BACKWARD_SELECTED, #JOG_FW_AND_BW_SELECTED:
	      // Additional features (applicative): Jog mode incremental
	      REGION JOG_SELECTED
	        CASE #statJogMode OF
	          #JOG_MODE_CONTINUOUS:
	            REGION JOG_MODE_CONTINUOUS
	              // No additional feature
	              // Firstcycle of command
	              IF (#statFirstCycleBasicMotion = TRUE) THEN
	                // No of dynmics into static variables because changes are accepted by MC_JOG immetiately (enable)
	                #instMoveJog(Axis := #axis,
	                             JogForward := FALSE,
	                             JogBackward := FALSE);
	              END_IF;
	              
	              // Call MC_Command
	              #instMoveJog(Axis := #axis,
	                           JogForward := #statBasicCommand.%X2,
	                           JogBackward := #statBasicCommand.%X3,
	                           Velocity := #configuration.jog.velocity,
	                           Acceleration := #configuration.jog.acceleration,
	                           Deceleration := #configuration.jog.deceleration,
	                           PositionControlled := #configuration.jog.positionControlled,
	                           Jerk := #configuration.jog.jerk);
	              
	              // Evaluate MC_Command
	              IF (#instMoveJog.Busy = FALSE) AND
	                (#instMoveJog.Error = FALSE) AND
	                (#instMoveJog.CommandAborted = FALSE) AND
	                (#instMoveJog.InVelocity = FALSE)
	              THEN
	                // Return to NO_SELECTION if command finished
	                #statBasicMotionState := #NO_SELECTION;
	                
	              ELSIF (#instMoveJog.Error = TRUE)
	              THEN
	                // Errorhandling
	                #statStatus := #ERR_MC_MOVEJOG;
	                #statErrorAutoCleared := TRUE;
	                #statDiagnostics.subfunctionStatus := #statSubfunctionStatus := #instMoveJog.ErrorId;
	                // Set next state
	                #statBasicMotionState := #NO_SELECTION;
	                #statFBState := #AXIS_STOP_ON_ERROR_SELECTION;
	              ELSE
	                ; // Command selected
	              END_IF;
	              
	              // Write MC_Command outputs to internal variable
	              #statExeOfBasicMotion := 16#0;
	              #statExeOfBasicMotion.%X0 := #instMoveJog.Busy;
	              #statExeOfBasicMotion.%X2 := #instMoveJog.CommandAborted;
	              #statExeOfBasicMotion.%X3 := #instMoveJog.Error;
	              #statExeOfBasicMotion.%X4 := #instMoveJog.InVelocity;
	            END_REGION
	          ELSE
	            // Errorhandling - Invalid jog state
	            #statStatus := #ERR_INVALID_JOG_MODE;
	            #statErrorAutoCleared := TRUE;
	            #statDiagnostics.subfunctionStatus := #statSubfunctionStatus := 0;
	            // Set next state
	            #statFBState := #AXIS_STOP_ON_ERROR_SELECTION;
	            #statBasicMotionState := #NO_SELECTION;
	        END_CASE;
	      END_REGION
	      
	    #MOVE_VELOCITY_SELECTED:
	      // Additional features (applicative): Change setpoint on the fly (Velocity) 
	      REGION MOVEVELOCITY_SELECTED
	        // Firstcycle of command
	        IF (#statFirstCycleBasicMotion = TRUE) THEN
	          // Reset MC_MOVEVELOCITY command
	          #instMoveVelocity(Axis := #axis,
	                            Execute := FALSE);
	          
	          #statVelocityChangeOnTheFly := #configuration.moveVelocity.velocityChangeOnTheFly;
	          #statVelocity := #configuration.moveVelocity.velocity;                     // Store the last adjusted velocity value
	          #statAcceleration := #configuration.moveVelocity.acceleration;             // Store the last adjusted acceleration value
	          #statDeceleration := #configuration.moveVelocity.deceleration;             // Store the last adjusted deceleration value
	          #statJerk := #configuration.moveVelocity.jerk;                             // Store the last adjusted jerk value 
	          #statDirection := #configuration.moveVelocity.direction;                   // Store the last adjusted axis direction 
	          #statPositionControlled := #configuration.moveVelocity.positionControlled; // Store the last adjusted motion mode
	          
	        ELSIF (#statVelocityChangeOnTheFly = TRUE) AND (#configuration.moveVelocity.velocity <> #statVelocity) // Velocity changed
	          AND (#instMoveVelocity.CommandAborted = FALSE)
	        THEN
	          // Reset MC_MOVEVELOCITY command
	          #instMoveVelocity(Axis := #axis,
	                            Execute := FALSE);
	          #statVelocity := #configuration.moveVelocity.velocity;           // Store the last adjusted velocity value
	          
	          // V1.0.5 Copy also dynamics
	          #statAcceleration := #configuration.moveVelocity.acceleration;             // Store the last adjusted acceleration value
	          #statDeceleration := #configuration.moveVelocity.deceleration;             // Store the last adjusted deceleration value
	          #statJerk := #configuration.moveVelocity.jerk;                             // Store the last adjusted jerk value 
	          #statDirection := #configuration.moveVelocity.direction;                   // Store the last adjusted axis direction 
	          #statPositionControlled := #configuration.moveVelocity.positionControlled; // Store the last adjusted motion mode
	        END_IF;
	        
	        // Call MC_Command
	        #instMoveVelocity(Axis := #axis,
	                          Execute := #statBasicCommand.%X4 OR #statFirstCycleBasicMotion, // Input: moveVelocity
	                          Velocity := #statVelocity,
	                          Acceleration := #statAcceleration,
	                          Deceleration := #statDeceleration,
	                          Jerk := #statJerk,
	                          Direction := #statDirection,
	                          PositionControlled := #statPositionControlled,
	                          Current := FALSE);
	        
	        // Evaluate MC_Command
	        IF (#instMoveVelocity.Busy = FALSE) AND
	          (#instMoveVelocity.Error = FALSE) AND
	          (#instMoveVelocity.CommandAborted = FALSE) AND
	          (#instMoveVelocity.InVelocity = FALSE)
	        THEN
	          // Return to NO_SELECTION if command finished
	          #statBasicMotionState := #NO_SELECTION;
	          
	        ELSIF (#instMoveVelocity.Error = TRUE)
	        THEN
	          // Errorhandling
	          #statStatus := #ERR_MC_MOVEVELOCITY;
	          #statErrorAutoCleared := TRUE;
	          #statDiagnostics.subfunctionStatus := #statSubfunctionStatus := #instMoveVelocity.ErrorId;
	          #statVelocityChangeOnTheFly := FALSE;
	          // Set next state
	          #statFBState := #AXIS_STOP_ON_ERROR_SELECTION;
	          #statBasicMotionState := #NO_SELECTION;
	        ELSE
	          ; // Command selected
	        END_IF;
	        
	        // Write MC_Command outputs to internal variable
	        #statExeOfBasicMotion := 16#0;
	        #statExeOfBasicMotion.%X0 := #instMoveVelocity.Busy;
	        #statExeOfBasicMotion.%X2 := #instMoveVelocity.CommandAborted;
	        #statExeOfBasicMotion.%X3 := #instMoveVelocity.Error;
	        #statExeOfBasicMotion.%X4 := #instMoveVelocity.InVelocity;
	      END_REGION
	      
	    ELSE
	      // Errorhandling
	      #statStatus := #ERR_UNDEFINED_BASIC_MOTION_STATE;
	      #statErrorUserCleared := TRUE;
	      #statDiagnostics.subfunctionStatus := #statSubfunctionStatus := 0;
	      // Set errorstate
	      #statFBState := #FB_ERROR;
	  END_CASE;
	END_REGION
	
	//----------------------------------------------------------------------------------------------
	// Execution of torquelimiting functionality
	//----------------------------------------------------------------------------------------------
	REGION EXECUTION_OF_TORQUELIMTING
	  // Statemachine for torquelimiting 
	  REPEAT
	    #tempStateChangeActive := FALSE;
	    CASE #statTorqueLimitingState OF
	      #NO_TORQUE_LIMITING_ACTIVE:
	        ;
	        
	      #TORQUE_LIMITING_DISABLE:
	        // Torquelimiting disable
	        #instTorqueLimiting(Axis := #axis,
	                            Enable := FALSE);
	        
	        // Check state of torque limting
	        IF (#instTorqueLimiting.Busy = FALSE)
	        THEN
	          // set next state
	          #statTorqueLimitingState := #NO_TORQUE_LIMITING_ACTIVE;
	        ELSE
	          ; // Waiting for MC_Torquelimiting is not busy
	        END_IF;
	        
	      #TORQUE_LIMTING_SELECTED:
	        // No extended homing function active
	        #instTorqueLimiting(Axis := #axis,
	                            Enable := #statExtendedCommand.%X1,
	                            Limit := #configuration.torqueLimiting.limit,
	                            Mode := #configuration.torqueLimiting.mode);
	        
	        IF (#instTorqueLimiting.Busy = FALSE) THEN
	          // Reset state
	          #statTorqueLimitingState := #NO_TORQUE_LIMITING_ACTIVE;
	        END_IF;
	        
	      ELSE
	        // Errorhandling
	        #statStatus := #ERR_UNDEFINED_TORQUE_LIMITING_STATE;
	        #statErrorUserCleared := TRUE;
	        #statDiagnostics.basicMotionState := #statBasicMotionState;
	        #statDiagnostics.subfunctionStatus := #statSubfunctionStatus := 0;
	        // Set errorstate
	        #statFBState := #FB_ERROR;
	    END_CASE;
	  UNTIL (#tempStateChangeActive = FALSE)
	  END_REPEAT;
	  // Evaluate MC_Command
	  IF (#instTorqueLimiting.Error = TRUE) AND ((#statTorqueLimitingErrorOld = FALSE) OR (#statStatus = #STATUS_SUBSEQUENT_CALL)) THEN
	    // Errorhandling
	    #statStatus := #ERR_MC_TORQUELIMITING;
	    #statErrorAutoCleared := TRUE;
	    #statDiagnostics.basicMotionState := #statBasicMotionState;
	    #statDiagnostics.subfunctionStatus := #statSubfunctionStatus := #instTorqueLimiting.ErrorId;
	    
	    #statFBState := #AXIS_STOP_ON_ERROR_SELECTION;
	    
	  ELSIF (#instTorqueLimiting.Error = FALSE) AND ((#statTorqueLimitingErrorOld = TRUE) AND (#statStatus = #ERR_MC_TORQUELIMITING)) THEN
	    #statStatus := #STATUS_SUBSEQUENT_CALL;
	    #statErrorAutoCleared := FALSE;
	  ELSE
	    ;
	  END_IF;
	  
	  #statTorqueLimitingErrorOld := #instTorqueLimiting.Error;
	END_REGION
	
	//----------------------------------------------------------------------------------------------
	// Selection of StopOnError / implementation of fastStop
	//----------------------------------------------------------------------------------------------
	REGION STOP_ON_ERROR
	  // Check for stopping if error occurred during execution of motion commands
	  IF (#statFBState = #AXIS_STOP_ON_ERROR_SELECTION)
	  THEN
	    #statBasicMotionState := #NO_SELECTION;
	    
	    IF (#configuration.generalSettings.stopOnError = TRUE)
	    THEN
	      // Read Statusword
	      #tempStatusWord := #axis.StatusWord;
	      
	      // Evaluate error
	      IF #tempStatusWord.%X0 THEN
	        // Axis enabled
	        IF (#tempStatusWord.%X1 = TRUE) THEN
	          // TO Alarm present
	          #statFBState := #AXIS_MOTION;
	        ELSE
	          // No TO alarm present, set fastStop
	          //#statBasicMotionState := #FAST_STOP_SELECTED; // V1.1.0
	          #statStopWithoutSignalization := TRUE; // V1.1.0
	          #statFirstCycleBasicMotion := TRUE;
	          #statFBState := #AXIS_STOP_ON_ERROR_EXECUTION;
	        END_IF;
	      ELSE
	        // Axis disabled
	        #statFBState := #AXIS_MOTION;
	      END_IF;
	    ELSE
	      // Dont StopOnError
	      #statFBState := #AXIS_MOTION;
	    END_IF;
	  END_IF;
	  
	  // Implementation of fastStop
	  IF (#statBasicMotionState = #FAST_STOP_SELECTED)
	    OR #statStopWithoutSignalization
	  THEN
	    // Additional feature: Load emergency stop dynamics (TO) if no valid dynamics are configured for fastStop
	    REGION FASTSTOP SELECTED
	      // Firstcycle of command
	      IF (#statFirstCycleBasicMotion = TRUE) THEN
	        // Reset HALT command
	        #instHalt(Axis := #axis,
	                  Execute := FALSE);
	        #statFirstCycleDone := TRUE;
	        // Check dynamics for fastStop
	        // Load TO emergency Stop dynamics if value <=0 for deceleration is configured
	        IF (#configuration.fastStop.deceleration <= 0.0) // V1.0.2 Read TO emergencyStop deceleration only if fastStop.deceleration <= 0
	        THEN
	          // Invalid fastStop dynamics configured - read emergency stop dynamics from TO
	          #statDeceleration := #axis.DynamicDefaults.EmergencyDeceleration;
	        ELSE
	          // Valid fastStop dynamics configured
	          #statDeceleration := #configuration.fastStop.deceleration;
	        END_IF;
	        #statJerk := #configuration.fastStop.jerk; // V1.0.2 Use always configuration for jerk value
	        #statAbortAcceleration := #configuration.fastStop.abortAcceleration; // V1.0.2 Use always configuration
	      END_IF;
	      
	      // Call of MC_Command
	      #instHalt(Axis := #axis,
	                Execute := (#statBasicCommand.%X0 OR #statFirstCycleBasicMotion),
	                Deceleration := #statDeceleration,
	                AbortAcceleration := #statAbortAcceleration,
	                Jerk := #statJerk);
	      
	      // Evaluate MC_Command
	      IF (#instHalt.Busy = FALSE) AND
	        (#instHalt.Error = FALSE) AND
	        (#instHalt.Done = FALSE) AND
	        (#instHalt.CommandAborted = FALSE)
	      THEN
	        // Return to NO_SELECTION if command finished
	        #statFBState := #AXIS_MOTION;
	        #statBasicMotionState := #NO_SELECTION;
	        #statStopWithoutSignalization := FALSE; // V1.1.0
	        
	      ELSIF (#instHalt.Done = TRUE)
	      THEN
	        IF (#statFirstCycleDone = TRUE)
	        THEN
	          // Command is reset
	          IF (#instTorqueLimiting.Error = FALSE) // V1.00.03 Dont reset error is pending
	          THEN
	            // Reset status not if torquelimiting error is pending
	            IF #statStopWithoutSignalization THEN
	              ;
	            ELSE
	              #statStatus := #STATUS_SUBSEQUENT_CALL;
	              #statErrorAutoCleared := FALSE;
	            END_IF;
	          END_IF;
	          
	          #statFirstCycleDone := FALSE;
	        END_IF;
	      ELSE
	        ; // Command selected
	      END_IF;
	      
	      // Write MC_Command outputs to internal variable
	      #statExeOfBasicMotion := 0;
	      #statExeOfBasicMotion.%X0 := #instHalt.Busy;
	      #statExeOfBasicMotion.%X1 := #instHalt.Done;
	      #statExeOfBasicMotion.%X2 := #instHalt.CommandAborted;
	      #statExeOfBasicMotion.%X3 := #instHalt.Error;
	    END_REGION
	  END_IF;
	END_REGION
	//----------------------------------------------------------------------------------------------
	// Store values and reset variables
	//----------------------------------------------------------------------------------------------
	REGION STORE_AND_RESET
	  // Reset variables to determine first cycle of a new command
	  IF (#statFirstCycleReset = TRUE) THEN
	    #statFirstCycleReset := FALSE;
	  END_IF;
	  #statFirstCycleBasicMotion := FALSE;
	  #statBasicCommandOld := #statBasicCommand;
	  
	  // Store last values for edge detection
	  #statEnableOld := #tempEnable;
	  #statEnableAxisOld := #tempEnableAxis;
	  #statExtendedCommandOld := #statExtendedCommand;
	  #statPowerErrorOld := #instPower.Error;
	END_REGION
	
	//----------------------------------------------------------------------------------------------
	// Writing outputs
	//----------------------------------------------------------------------------------------------
	REGION WRITING_OF_OUTPUTS
	  // Writing status outputs
	  #resetActive := (#statResetState = #CMD_BUSY);
	  
	  IF (#statErrorUserCleared = TRUE) THEN
	    ; // Reset variables at ErrorUserCleared
	    #statBasicMotionState := #NO_SELECTION;
	    #statExeOfBasicMotion := #NO_SELECTION;
	  END_IF;
	  IF (#instPower.Status = TRUE)
	  THEN
	    // Axis enabled
	    #axisEnabled := TRUE;
	    
	  ELSIF (#instPower.Error = TRUE) AND (#instPower.Status = FALSE)
	  THEN
	    // Reset status if error occurred
	    #axisEnabled := FALSE;
	    
	  ELSIF (#instPower.Busy = FALSE)
	  THEN
	    // Reset if MC_Power is not busy
	    #axisEnabled := FALSE;
	  ELSE
	    ;
	  END_IF;
	  
	  REGION WRITING_BASICMOTION_OUTPUTS
	    // Writing Busy, Done and Aborted outputs for basic motion commands
	    IF (#statBasicMotionState > #NO_SELECTION) AND (#statBasicMotionState < #ACTIVE_HOMING_SELECTED)
	    THEN
	      #commandBusy := #statExeOfBasicMotion.%X0;
	      #commandDone := #statExeOfBasicMotion.%X1;
	      #commandAborted := #statExeOfBasicMotion.%X2;
	      #inVelocity := #statExeOfBasicMotion.%X4;
	    ELSE
	      #commandBusy := FALSE;
	      #commandDone := FALSE;
	      #commandAborted := FALSE;
	      #inVelocity := FALSE;
	    END_IF;
	    
	    // Writing outputs up to LAxisCtrl_SpeedAxis
	    IF (#statTorqueLimitingState = #TORQUE_LIMTING_SELECTED)
	    THEN
	      #torqueLimitingSelected := TRUE;
	    ELSE
	      #torqueLimitingSelected := FALSE;
	    END_IF;
	    
	    #inLimitation := #instTorqueLimiting.InLimitation;
	    #fastStopSelected := #statBasicMotionState.%X0;
	    #stopSelected := #statBasicMotionState.%X1;
	    #jogSelected := #statBasicMotionState.%X2 OR #statBasicMotionState.%X3;
	    #moveVelocitySelected := #statBasicMotionState.%X4;
	  END_REGION
	END_REGION
	
	//----------------------------------------------------------------------------------------------
	// Error handling 
	//----------------------------------------------------------------------------------------------
	REGION ERROR_HANDLING
	  IF #statErrorUserCleared THEN
	    #valid := FALSE;
	    #busy := TRUE;
	    #error := TRUE;
	    #status := #statStatus;
	    #subfunctionStatus := #statSubfunctionStatus; // V1.1.0
	    #statDiagnostics.status := #statStatus;
	    
	  ELSIF #statErrorAutoCleared THEN
	    #valid := FALSE;
	    #busy := TRUE;
	    #error := TRUE;
	    #status := #statStatus;
	    #subfunctionStatus := #statSubfunctionStatus; // V1.1.0
	    #statDiagnostics.status := #statStatus;
	    
	  ELSE
	    // Process normal output values
	    #valid := TRUE;
	    #error := FALSE;
	    #status := #statStatus;
	    #subfunctionStatus := #statSubfunctionStatus := 16#0; // V1.1.0
	  END_IF;
	  
	  #diagnostics := #statDiagnostics; // V1.1.0
	END_REGION
END_FUNCTION_BLOCK

