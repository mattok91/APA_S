FUNCTION_BLOCK "fbMeasureAvgCapacityCount"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      inEnable { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      inRENewTU { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      inBaseTimeIntervall : Time := T#1s;
   END_VAR

   VAR_OUTPUT 
      ouCapacitiyHeadToHead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;
      ouTimeHeadToHead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
      ouBuffer { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "typeBufferCountTUs";
   END_VAR

   VAR 
      sActivateHeadToHead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      tLowerBound : DInt;
      tUpperBound : DInt;
   END_VAR

   VAR CONSTANT 
      cTimeIntervall : Time := T#1S;
   END_VAR


BEGIN
	// Get array boundaries
	"fcGetBoundariesUSIntArray"(inArray         := #ouBuffer.Value,
	                            ouUpperBoundary => #tUpperBound,
	                            ouLowerBoundary => #tLowerBound);
	
	#ouBuffer.BaseTimeIntervall := #inBaseTimeIntervall;
	
	IF #inEnable THEN
	  REGION Counters
	    // Counter time head to head
	      #ouBuffer.TimeHeadToHead += "CycleTimeData".PrevScanTime."Time";
	    // Counter time measuring intervall
	      #ouBuffer.TimeIntervall += "CycleTimeData".PrevScanTime."Time";
	  END_REGION
	  
	  IF #inRENewTU THEN
	    REGION New TU detected     
	      #ouBuffer.CurrentValue += 1;
	      IF #sActivateHeadToHead THEN
	        // Calc current capacity
	        #ouTimeHeadToHead := #ouBuffer.TimeHeadToHead;
	        #ouCapacitiyHeadToHead := UDINT_TO_UINT(3_600_000 / TIME_TO_UDINT(#ouTimeHeadToHead));
	        // Init time head to head
	        #ouBuffer.TimeHeadToHead := t#0ms;
	      END_IF;
	      #sActivateHeadToHead := true;
	    END_REGION
	  END_IF;
	  
	  IF #ouBuffer.TimeIntervall >= #inBaseTimeIntervall THEN
	    REGION Intervalltime reached
	      // Calc restart of timer
	        #ouBuffer.TimeIntervall -= #inBaseTimeIntervall;
	      // Get next index
	      #ouBuffer.CurrentIndex += 1;
	      IF #ouBuffer.CurrentIndex < #tLowerBound OR #ouBuffer.CurrentIndex > #tUpperBound THEN
	        #ouBuffer.CurrentIndex := #tLowerBound;
	      END_IF;
	      // Save value in bufer
	      #ouBuffer.Value[#ouBuffer.CurrentIndex] := #ouBuffer.CurrentValue;
	      #ouBuffer.CurrentValue := 0;
	      // Calc values added
	      #ouBuffer.ValuesInBuffer := MIN(IN1 := #ouBuffer.ValuesInBuffer + 1,
	                                      IN2 := DINT_TO_UDINT(ABS(#tUpperBound - #tLowerBound)));
	    END_REGION
	  END_IF;
	  
	ELSE
	  // Reset all values
	  #sActivateHeadToHead := false;
	  #ouBuffer.TimeHeadToHead := t#0s;
	  #ouBuffer.TimeIntervall := t#0s;
	  #ouBuffer.CurrentValue := 0;
	  #ouBuffer.ValuesInBuffer := 0;
	  #ouBuffer.CurrentIndex := #tLowerBound - 1;
	END_IF;
END_FUNCTION_BLOCK

